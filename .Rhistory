eigens <- sapply(sim.results, "[[", 2)
# Get time stamp
times <- sapply(sim.results, "[[",3)
# Get final matrix structure
fin.mats <- unlist(lapply(allmats, tail, 1), recursive = F)
lstr <- link_structure(fin.mats)
pairs <- lapply(allmats, function(x){lapply(x, function(z){data.frame(aij = z[upper.tri(z)], aji = t(z)[upper.tri(z)])})})
allpair <- rbindlist(unlist(lapply(pairs, function(x){tail(x, 1)}), recursive = F))
d.all <- list()
for(x in 1:n.web){
class.l <- list(very = lstr$very[[x]], mod = lstr$mod[[x]], unst = lstr$unst[[x]])
d.all[[x]] <- classify(fin.mats[[x]], class.l)
#print(x)
}
mag.class[[i]] <- cbind(allpair, class = factor(unlist(d.all), levels = c("0", "UNST", "MOD", "VERY")))
print(i)
}
n.web = 100
mag.class <- list()
for(i in 1:1000){
erg <- init_cond(n.web, S = 150, C = .1)
#system.time(
sim.results <- lapply(erg, eigenTRACE.v2, x = 2000)
#)
# 458 for 1000, 1000, 10sp .2C
# Get all matrices
allmats <- sapply(sim.results, "[[", 1)
# Get eigenvalues for each matrix
eigens <- sapply(sim.results, "[[", 2)
# Get time stamp
times <- sapply(sim.results, "[[",3)
# Get final matrix structure
fin.mats <- unlist(lapply(allmats, tail, 1), recursive = F)
lstr <- link_structure(fin.mats)
pairs <- lapply(allmats, function(x){lapply(x, function(z){data.frame(aij = z[upper.tri(z)], aji = t(z)[upper.tri(z)])})})
allpair <- rbindlist(unlist(lapply(pairs, function(x){tail(x, 1)}), recursive = F))
d.all <- list()
for(x in 1:n.web){
class.l <- list(very = lstr$very[[x]], mod = lstr$mod[[x]], unst = lstr$unst[[x]])
d.all[[x]] <- classify(fin.mats[[x]], class.l)
#print(x)
}
mag.class[[i]] <- cbind(allpair, class = factor(unlist(d.all), levels = c("0", "UNST", "MOD", "VERY")))
print(i)
}
setwd("C:/Users/jjborrelli/OneDrive/Documents/evoMOD")
temperature = 278 #as.numeric(temperature);
print(temperature);
s = 1 #as.numeric(s);
print(s);
alpha=0.5; ##interference competition constant
beta=0.25; ##threshold body size difference for competitive interference. also ran at beta = 1
setwd(paste(".../Mut_a_",alpha,"_s_",s,"_Temp_",temperature,"_beta_",beta,sep=""));
library(odesolve);
library(deSolve)
?lsoda
temperature = 278 #as.numeric(temperature);
print(temperature);
s = 1 #as.numeric(s);
print(s);
alpha=0.5; ##interference competition constant
beta=0.25; ##threshold body size difference for competitive interference. also ran at beta = 1
#setwd(paste(".../Mut_a_",alpha,"_s_",s,"_Temp_",temperature,"_beta_",beta,sep=""));
library(odesolve);
##Start matricies
biomass <- matrix(c(NA),ncol=1,nrow=1)  ##initial biomass of the original species##
nuts <- matrix(c(NA),ncol=1,nrow=1)  ##initial nutrient pool##
size <- matrix(c(NA),ncol=1,nrow=1)  ##initial size of the original species is defined as d##
deltasize <- seq(0.8,1.2,0.01) ##the proportional change in body size##
##start constants
mut=14722190*exp(-0.65/((8.617*10^-5)*temperature)) ##mutation probability = 10^-04 for temp=298 and body size=5
addsp <- 1e-20 ##biomass of new species##
I=10 ##constant input of nutrients and the initial amount##
e=0.1 ##nutrient output rate##
v=0.5 ##percentage of remaining nutrient during recycling##
f=0.25 ##feeding efficiency constant##
m=0.1 ##mortality constant##
gamma=1.189 ##constant in the feeding function
D=2 ##optimal body size difference in feed.fun##
increment = 1000; ## how often the simulation is sampled
time=10000; ## maximum time
sample <- seq(increment,time,increment); ## vector of sample times
###general feeding and interference competition functions###
g <- function(xi,xj) {gamma*(xi^-0.25)/s/sqrt(2*pi)*exp(-(xi-xj-D)^2/s^2)} ##general feeding function
a <- function(xi,xj) {ifelse(abs(xi-xj)>beta,0,alpha)} ##general interference function
##Initializing the initial vectors##
biomass[1] = 1e-20 ##Initial biomass
nuts[1] = I ##initial nutrient pool
size[1] = 2 ##initial body size
biomass <- cbind(nuts,biomass)
size <- cbind(0,size)
comp <- rbind(size,biomass)
##End constants
##function for the diff. eq. approx.
biomupdate <- function (t,y,parms){ ##function going into lsoda
for (x in 2:parms[8]) { ##this starts at two because I put the nutrients in there as the first column
out[x] <- ##updated biomass for species x
y[x]*(
f*sum(y[1:(x-1)]*g(size[x],size[1:(x-1)]))- ##feeding
m*(size[x]^-0.25)- ##mortality
sum(y[2:parms[8]]*a(size[x],size[2:length(size)]))- ##interference comp
ifelse(x==parms[8],0,sum(y[(x+1):parms[8]]*g(size[(x+1):length(size)],size[x]))) ##predated
)
}
ineffup <- 0
for (i in 2:parms[8]) {
ineff <- y[i]*(1-f)*sum(y[1:(i-1)]*g(size[i],size[1:(i-1)])) ##from inefficient feeding
ineffup <- ineff+ineffup
};
ineff.feed = ineffup;
interup = 0
for (i in 2:parms[8]) {
inter = y[i]*sum(y[2:parms[8]]*a(size[i],size[2:length(size)])) ##from interference comp
interup = interup+inter
}
interference = interup;
out[1] <- I-e*y[1]+
v*(
sum(m*(size[2:length(size)]^-0.25)*y[2:parms[8]])+ ##from mortality
interference+ ##from interference comp.
ineff.feed ##from inefficient feeding
) -
sum(y[1]*y[2:parms[8]]*g(size[2:length(size)],0)); ##loss due to direct nutrient consumption
list(c(out),c(0))
}
for (tm in 1:time) { ##start of main loop
comp <- matrix(c(comp[,order(comp[1,],decreasing=F)]),nrow=2) ##orders comp by increasing size and keeps the biomass of each species attached to its size##
biomass <- matrix(c(comp[2,]),nrow=1)
size <- matrix(c(comp[1,]),nrow=1)
species <- ncol(biomass)
parms <- matrix(c(f,m,gamma,s,D,beta,alpha,species,I,e,v,size),nrow=1)
out <- matrix(c(NA),ncol=ncol(biomass),nrow=1)
times <- seq(0,1,1)
newbiomass <- lsoda(biomass,times,biomupdate,parms,rtol=1e-10,atol=1e-10)
newbiomass <- matrix(c(newbiomass[2,2:(ncol(newbiomass)-1)]),nrow=1)
newsize <- size
###Evolution Starts Here###
for (i in 2:parms[8]) {
mutprob <- mut*biomass[i]*size[i]^-0.25
temprob <- c(max(0,1-mutprob),min(1,mutprob))
speciate <- sample(c(0,1),1,prob=temprob)
if(speciate==1) { newbiomass <- cbind(newbiomass,1e-20); newsize <- cbind(newsize,size[i]*sample(deltasize,1))  } else{}
}
####evolution stops####
for (z in 2:length(newbiomass)) {if (newbiomass[z]<1e-20) {newbiomass[z] <- NA} else {}}
comp <- as.matrix(t(na.omit(t(rbind(newsize,newbiomass)))))
if (ncol(comp)==2) {} else{for (z in 2:(ncol(comp)-1)) {if (comp[1,z]==comp[1,(z+1)]) {comp[2,z] <- comp[2,z]+comp[2,(z+1)]} else{}; if (comp[1,z]==comp[1,(z+1)]) {comp[2,z+1] <- NA} else{}}}
comp <- t(na.omit(t(comp)))
row.names(comp) <- c("size","biomass")
if (is.element(tm,sample)==TRUE) {
timesoutput <- matrix(c(tm),ncol=1,nrow=ncol(comp))
results <- cbind(timesoutput,t(comp))
colnames(results) <- c("time","size","biomass")
write.table(results,paste("results_",tm,".txt",sep=""),col.name=T,row.name=F,quote=F,sep="\t")
} else{};
} ##End of big loop
results
timesoutput
comp
setwd("C:/Users/jjborrelli/Dropbox/Food Web Database/Parasites/Pilosof_et_al_2013/")
pnet.names <- list.files()
pnets <- list()
for(i in 1:length(pnet.names)){
pnets[[i]] <- read.csv(pnet.names[i], row.names = 1)
}
sapply(pnets, dim)
pnets[[1]]
pnets[[1]] == pnets[[2]]
library(bipartite)
library(betalink)
names(pnets) <- c(1982:1987)
pnets <- lapply(pnets, as.matrix)
pnet.g <- prepare_networks(pnets)
pnet.g
mweb <- metaweb(pnet.g)
mweb
madj <- get.adjacency(mweb, sparse = F)
graphs <- list(mweb, pnet.g)
library(TrophInd)
library(NetIndices)
mats <- lapply(graphs, get.adjacency)
graphs
graphs <- list(mweb, unlist(pnet.g))
graphs
graphs <- list(mweb, unlist(pnet.g, recursive = F))
graphs
dim(madj)
plotweb(madj)
visweb(madj)
madj
dim(madj)
pnet.g
pnet.g[[1]]
length(pnet.g)
get.adjacency(pnet.g)
get.adjacency(pnet.g[[1]])
lapply(pnet.g, get.adjacency)
graphs <- list(madj, lapply(pnet.g, get.adjacency, sparse = F))
mats <- list(madj, lapply(pnet.g, get.adjacency, sparse = F))
rm(graphs)
inds <- lapply(mats, GenInd)
inds <- sapply(mats, function(x){sum(x)/(nrow(x)*ncol(x))})
mats[[1]]
length(mats)
mats <- list(madj, sapply(pnet.g, get.adjacency, sparse = F))
length(mats)
?append
mats <- append(madj, sapply(pnet.g, get.adjacency, sparse = F))
length(mats)
mats <- append(sapply(pnet.g, get.adjacency, sparse = F), madj)
length(mats)
mats <- list(madj, unlist(sapply(pnet.g, get.adjacency, sparse = F), recursive = F))
mats
unlist(sapply(pnet.g, get.adjacency, sparse = F), recursive = F)
sapply(pnet.g, get.adjacency, sparse = F)
test <- sapply(pnet.g, get.adjacency, sparse = F)
str(test)
?unlist
is.list(test)
unlist(test, recursive = F)
t.adj <- sapply(pnet.g, get.adjacency, sparse = F)
t.adj$1982
t.adj$"1982"
mats <- list(madj, t.adj$"1982", t.adj$"1983", t.adj$"1984", t.adj$"1985", t.adj$"1986", t.adj$"1987")
inds <- sapply(mats, function(x){sum(x)/(nrow(x)*ncol(x))})
inds
inds <- sapply(t.adj, function(x){sum(x)/(nrow(x)*ncol(x))})
inds
hist(inds)
abline(sum(madj)/(nrow(madj)*ncol(madj)))
abline(v = sum(madj)/(nrow(madj)*ncol(madj)))
dev.off()
hist(inds)
abline(v = sum(madj)/(nrow(madj)*ncol(madj)))
plot(inds)
abline(h = sum(madj)/(nrow(madj)*ncol(madj)))
inds <- sapply(t.adj, function(x){sum(x);(nrow(x)*ncol(x))})
inds
inds <- sapply(t.adj, function(x){c(sum(x),(nrow(x)*ncol(x)))})
inds
plot(inds[1,], inds[2,])
points(sum(madj), (nrow(madj)*ncol(madj)), col = "blue", pch = 20)
sum(madj)
plot(sum(madj), (nrow(madj)*ncol(madj)), col = "blue", pch = 20)
points(inds[1,], inds[2,])
plot(sum(madj), (nrow(madj)*ncol(madj)), col = "blue", pch = 20, ylim = c(0, 9000), xlim = c(0,300))
points(inds[1,], inds[2,])
computeModules(madj)
res <- computeModules(madj)
plotModuleWeb(res)
mods <- lapply(t.adj, computeModules)
for(i in 1:4){
plotModuleWeb(mods[[i]])
}
library(cheddar)
require(cheddar)
require(igraph)
require(NetIndices)
# Get the data for 1984 Tuesday Lake
data(TL84)
# Get the adjacency matrix
tl.mat <- PredationMatrix(TL84)
n1 <- nrow(tl.mat)
# This calculate the motifs after eliminating one species from the network
m84 <- motif_counter(list(graph.adjacency(tl.mat)), web = "TL84")
mot84 <- motif_counter(list(graph.adjacency(tl.mat)), web = "TL84")
for(i in 1:n1){
temp <- tl.mat[-i, -i]
name <- paste("TL84", i, sep = "-")
t.mot <- motif_counter(list(graph.adjacency(temp)), web = name)
mot84 <- rbind(mot84, t.mot)
}
GenInd(tl.mat)
# Now I want to get the particular set of motifs that each species participates in
sp.profiles <- matrix(nrow = n1, ncol = 13)
colnames(sp.profiles) <- names(mot84[,2:14])
rownames(sp.profiles) <- rownames(tl.mat)
for(i in 1:n1){
diffs <- mot84[1, 2:14] - mot84[1+i, 2:14]
sp.profiles[i,] <- as.numeric(diffs)
}
motif_counter <- function(graph.lists){
require(igraph)
if(!is.list(graph.lists)){
stop("The input should be a list of graph objects")
}
triad.count <- lapply(graph.lists, triad.census)
triad.matrix <- matrix(unlist(triad.count), nrow = length(graph.lists), ncol = 16, byrow = T)
colnames(triad.matrix) <- c("empty", "single", "mutual", "s5", "s4", "s1", "d4",
"d3", "s2", "s3","d8", "d2", "d1", "d5", "d7", "d6")
triad.df <- as.data.frame(triad.matrix)
motif.data.frame <- data.frame(s1 = triad.df$s1, s2 = triad.df$s2, s3 = triad.df$s3, s4 = triad.df$s4,
s5 = triad.df$s5, d1 = triad.df$d1, d2 = triad.df$d2, d3 = triad.df$d3, d4 = triad.df$d4,
d5 = triad.df$d5, d6 = triad.df$d6, d7 = triad.df$d7, d8 = triad.df$d8)
rownames(motif.data.frame) <- names(graph.lists)
return(motif.data.frame)
}
m84 <- motif_counter(list(graph.adjacency(tl.mat)), web = "TL84")
mot84 <- motif_counter(list(graph.adjacency(tl.mat)), web = "TL84")
for(i in 1:n1){
temp <- tl.mat[-i, -i]
name <- paste("TL84", i, sep = "-")
t.mot <- motif_counter(list(graph.adjacency(temp)), web = name)
mot84 <- rbind(mot84, t.mot)
}
m84 <- motif_counter(list(graph.adjacency(tl.mat)))
mot84 <- motif_counter(list(graph.adjacency(tl.mat)))
for(i in 1:n1){
temp <- tl.mat[-i, -i]
t.mot <- motif_counter(list(graph.adjacency(temp)))
mot84 <- rbind(mot84, t.mot)
}
sp.profiles <- matrix(nrow = n1, ncol = 13)
colnames(sp.profiles) <- names(mot84[,2:14])
rownames(sp.profiles) <- rownames(tl.mat)
for(i in 1:n1){
diffs <- mot84[1, 2:14] - mot84[1+i, 2:14]
sp.profiles[i,] <- as.numeric(diffs)
}
for(i in 1:n1){
diffs <- mot84[1,] - mot84[1+i, ]
sp.profiles[i,] <- as.numeric(diffs)
}
sp.profiles
NPS(TL84)
lm(NPS(TL84)$M ~ sp.profiles)
sp.profiles
lm(NPS(TL84)$M ~ sp.profiles[, 1:7])
lm(NPS(TL84)$M ~ sp.profiles[, c(1:2, 4:7)])
summary(lm(NPS(TL84)$M ~ sp.profiles[, c(1:2, 4:7)]))
plot(NPS(TL84)$N~NPS(TL84)$M)
plot(NPS(TL84)$N~NPS(TL84)$M, log = "xy")
plot(log10(NPS(TL84)$N)~log10(NPS(TL84)$M))
lm(log10(NPS(TL84)$N)~log10(NPS(TL84)$M))
abline(lm(log10(NPS(TL84)$N)~log10(NPS(TL84)$M)))
library(cheddar)
library(magrittr)
## FUNCTIONS
### Counting triads in a list of networks (igraph graph objects)
motif_counter <- function(graph.lists){
require(igraph)
if(!is.list(graph.lists)){
stop("The input should be a list of graph objects")
}
triad.count <- lapply(graph.lists, triad.census)
triad.matrix <- matrix(unlist(triad.count), nrow = length(graph.lists), ncol = 16, byrow = T)
colnames(triad.matrix) <- c("empty", "single", "mutual", "s5", "s4", "s1", "d4",
"d3", "s2", "s3","d8", "d2", "d1", "d5", "d7", "d6")
triad.df <- as.data.frame(triad.matrix)
motif.data.frame <- data.frame(s1 = triad.df$s1, s2 = triad.df$s2, s3 = triad.df$s3, s4 = triad.df$s4,
s5 = triad.df$s5, d1 = triad.df$d1, d2 = triad.df$d2, d3 = triad.df$d3, d4 = triad.df$d4,
d5 = triad.df$d5, d6 = triad.df$d6, d7 = triad.df$d7, d8 = triad.df$d8)
return(motif.data.frame)
}
### Jacknife species to get list of subgraphs
listROLES <- function(x){
lam <- list()
for(i in 1:nrow(x)){
lam[[i]] <- x[-i,-i]
}
qgs <- lapply(lam, graph.adjacency)
m.each <- motif_counter(qgs)
m.all <- motif_counter(list(graph.adjacency(x)))
m2 <- matrix(nrow = nrow(m.each), ncol = 13)
for(i in 1:nrow(m.each)){
m2[i,] <- as.numeric(m.all - m.each[i,])
}
return(as.data.frame(m2))
}
## Data
data(TL84)
data(TL86)
degs84 <- data.frame(inD = InDegree(TL84), outD = OutDegree(TL84))
degs86 <- data.frame(inD = InDegree(TL86), outD = OutDegree(TL86))
degs84
degs86
??centrality
mots84 <- PredationMatrix(TL84) %>% graph.adjacency()
mots86 <- PredationMatrix(TL86) %>% graph.adjacency()
evcent(mots84)
evcent(mots86)
same <- rownames(s.part84) %in% rownames(s.part86)
NPS(TL84)
NPS(TL86)
PlotWebByLevel(TL84)
pmTL84 <- PredationMatrix(TL84)
pmTL86 <- PredationMatrix(TL86)
### Count subgraphs
mots84 <- PredationMatrix(TL84) %>% graph.adjacency() %>% list() %>% motif_counter()
mots86 <- PredationMatrix(TL86) %>% graph.adjacency() %>% list() %>% motif_counter()
### list subgraph participation
s.part84 <- listROLES(pmTL84)
rownames(s.part84) <- rownames(NPS(TL84))
colnames(s.part84) <- colnames(mots84)
s.part86 <- listROLES(pmTL86)
rownames(s.part86) <- rownames(NPS(TL86))
colnames(s.part86) <- colnames(mots86)
degs84 <- data.frame(inD = InDegree(TL84), outD = OutDegree(TL84))
degs86 <- data.frame(inD = InDegree(TL86), outD = OutDegree(TL86))
same <- rownames(s.part84) %in% rownames(s.part86)
same
g84 <- PredationMatrix(TL84) %>% graph.adjacency()
g86 <- PredationMatrix(TL86) %>% graph.adjacency()
evcent(g84)$vector[same]
data.frame(evcent(g84)$vector[same], evcent(g86)$vector[same])
rownames(s.part86) == rownames(s.part84)[same]
rownames(s.part84)[same]
intersect(rownames(s.part86), rownames(s.part84))
data.frame(evcent(g84)$vector[same2], evcent(g86)$vector[same2])
same2<- intersect(rownames(s.part86), rownames(s.part84))
data.frame(evcent(g84)$vector[same2], evcent(g86)$vector[same2])
plot(data.frame(evcent(g84)$vector[same2], evcent(g86)$vector[same2]))
cor.test(data.frame(evcent(g84)$vector[same2], evcent(g86)$vector[same2]))
cor.test(x = data.frame(evcent(g84)$vector[same2], y = evcent(g86)$vector[same2]))
cor.test(evcent(g84)$vector[same2], evcent(g86)$vector[same2])
same2
graph.union(g84, g86)
V(graph.union(g84, g86))
is.vector(V(graph.union(g84, g86)))
as.vector(V(graph.union(g84, g86)))
getwd()
setwd("C:/Users/jjborrelli/Desktop/GitHub/dynamic-subgraphs")
plot(graph.union(g84, g86))
plot(graph.union(g84, g86), layout = layout.circle
)
write.csv(V(graph.union(g84, g86)) file = "data/TL_species.csv")
write.csv(V(graph.union(g84, g86)), file = "data/TL_species.csv")
verts <- V(graph.union(g84, g86))
verts
names(verts)
data.frame(verts)
levels(verts)
?V
str(verts)
verts$lables
verts$labels
att(verts)
attr(verts)
attributes(verts)
names(g84)
sp.names <- graph.union(g84, g85) %>% get.adjacency(sparse = F) %>% colnames
sp.names <- graph.union(g84, g86) %>% get.adjacency(sparse = F) %>% colnames
sp.names
verts
write.csv(sp.names, file = "data/TL_species.csv")
library(taxize)
install.packages(taxize)
install.packages("taxize")
library(taxize)
version()
sessionInfo()
sp.names
sp.names[1:3]
tnrs(query = sp,names[1:3], source = "iPlant_TNRS")
tnrs(query = sp.names[1:3], source = "iPlant_TNRS")
tnrs(query = sp.names[1:3])
classification(sp.names[1:3])
classification(sp.names[1:3], db = "eol")
classification("Nostoc", db = "eol")
classification("Nostoc", db = "itis")
classification(query = sp.names[1:3], db = "itis")
source('~/.active-rstudio-document', echo=TRUE)
classification(sp.names, db = "itis")
gnr_resolve("Phoxinus neogaeus")
classification("Phoxinus neogaeus", db = "itis")
classification("Phoxinus neogaeus", db = "eol")
classification("Phoxinus neogaeus", db = "gbif")
sp.cl <- classification(sp.names, db = "itis")
sp.cl
sp.cl$Micropterus salmoides
sp.cl$"Micropterus salmoides"
cast(sp.cl$"Micropterus salmoides")
cast(sp.cl$"Micropterus salmoides", formula = rank~name)
library(reshape2)
cast(sp.cl$"Micropterus salmoides", formula = rank~name)
acast(sp.cl$"Micropterus salmoides", formula = rank~name)
acast(sp.cl$"Micropterus salmoides", formula = name~rank)
t(sp.cl$"Micropterus salmoides")
sp.cl$"Micropterus salmoides"
which(sp.cl == NA)
sapply(sp.cl, function(x){x == NA})
sp.cl
sapply(sp.cl, function(x){x == "NA"})
sapply(sp.cl, function(x){ifelse(x == NA, print("yes"), print("no"))})
sapply(sp.cl, function(x){ifelse(x == "NA", print("yes"), print("no"))})
sapply(sp.cl, function(x){ifelse(is.na(x), print("yes"), print("no"))})
sapply(sp.cl, function(x){ifelse(is.na(x), print("yes"), NULL})
sapply(sp.cl, function(x){ifelse(is.na(x), print("yes"), NULL)})
is.na(sp.cl)
sp.cl[1:2]
which(is.na(sp.cl))
sp.cl[!is.na(sp.cl)]
sp.cl[is.na(sp.cl)]
names(sp.cl[is.na(sp.cl)])
classification(names(sp.cl[is.na(sp.cl)]), db = "gbif")
spcl[is.na(sp.cl)]
sp.cl[is.na(sp.cl)]
sp.cl[is.na(sp.cl)] <- classification(names(sp.cl[is.na(sp.cl)]), db = "gbif")
sp.cl
sp.cl[is.na(sp.cl)]
?save
save(sp.cl, file = "data/TL_species_class.Rdata")
load("data/TL_species_class.Rdata")
sp.cl
classification("Diaptomus oregonensis", db = "itis")
classification("Diaptomus oregonensis", db = "gbif")
classification("Diaptomus oregonensis", db = "ncbi")
classification("Diaptomus oregonensis", db = "eol")
classification("Diaptomus oregonensis", db = "tropicos")
NPS(TL84)
TrophicChains(TL84)
TrophicLevels(TL84)
